#+AUTHOR: Zheng Zhicheng(ZZC)
#+DECSRIPTION: Doom emacs config
#+STARTUP: overview

* Path
#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t; -*-
(setq org_notes_dir "~/Documents/org/notes" ; org notes location
      zot_bib "~/Nutstore/1/Nutstore/Zotero-Library/Main.bib"; Zotero .bib 文件
      zot_pdf "~/Nutstore/1/Nutstore/Zotero-Library" ; Zotero 同步文件
      org_notes "~/Documents/org/notes/ref/") ; org-roam 文献笔记目录
(setq auth-sources '("~/.authinfo" "~/.authinfo.gpg"))
  (unless (file-exists-p org_notes_dir) (setq org_notes_dir nil))
  (unless (file-exists-p zot_bib) (setq zot_bib nil))
  (unless (file-exists-p zot_pdf) (setq zot_pdf nil))
  (unless (file-exists-p org_notes) (setq org_notes nil)) ; 防止文件不存在报错
#+END_SRC

* System related
** Detect System
#+begin_src emacs-lisp
  (setq my/is-windows (eq system-type 'windows-nt)) ; Windows
  (setq my/is-linux (eq system-type 'gnu/linux)) ; Linux
  (setq my/is-mac (eq system-type 'darwin)) ; mac
  (setq my/is-WSL
        (if (and (eq system-type 'gnu/linux)
                 (string-match-p "Microsoft" (shell-command-to-string "uname -r")))
            t
          nil)) ; WSL
  (setq my/is-terminal (not window-system)) ;GUI
#+end_src

** WSL
*** Browse url
#+begin_src emacs-lisp
  (when (and (eq system-type 'gnu/linux)
             (string-match
              "Linux.*Microsoft.*Linux"
              (shell-command-to-string "uname -a")))
    (setq
     browse-url-generic-program  "/mnt/c/Windows/System32/cmd.exe"
     browse-url-generic-args     '("/c" "start")
     browse-url-browser-function #'browse-url-generic))

#+end_src

* Edit
#+begin_src emacs-lisp :tangle yes
(after! evil
  (setq evil-escape-key-sequence "jj")
  (setq evil-escape-delay 0.2)) ;; Adjust delay if needed
#+end_src
** save
#+BEGIN_SRC emacs-lisp
(use-package! super-save
  :config
  (super-save-mode +1)
  (setq super-save-auto-save-when-idle t)
  (setq super-save-delete-trailing-whitespace t)
  (setq auto-save-default nil)
  (setq super-save-exclude '(".gpg")))
#+END_SRC

* Window
** keymap
#+begin_src emacs-lisp
(defun my/resize-window-up ()
  "Increase window height repeatedly."
  (interactive)
  (enlarge-window 1)
  (set-transient-map
   (let ((map (make-sparse-keymap)))
     (define-key map (kbd "<up>") 'my/resize-window-up)
     map)
   t))

(defun my/resize-window-down ()
  "Decrease window height repeatedly."
  (interactive)
  (shrink-window 1)
  (set-transient-map
   (let ((map (make-sparse-keymap)))
     (define-key map (kbd "<down>") 'my/resize-window-down)
     map)
   t))

(defun my/resize-window-right ()
  "Increase window width repeatedly."
  (interactive)
  (enlarge-window-horizontally 1)
  (set-transient-map
   (let ((map (make-sparse-keymap)))
     (define-key map (kbd "<right>") 'my/resize-window-right)
     map)
   t))

(defun my/resize-window-left ()
  "Decrease window width repeatedly."
  (interactive)
  (shrink-window-horizontally 1)
  (set-transient-map
   (let ((map (make-sparse-keymap)))
     (define-key map (kbd "<left>") 'my/resize-window-left)
     map)
   t))

;; Bind these to SPC + arrow keys
(map! :leader
      :desc "Resize window up"    "<up>"    #'my/resize-window-up
      :desc "Resize window down"  "<down>"  #'my/resize-window-down
      :desc "Resize window right" "<right>" #'my/resize-window-right
      :desc "Resize window left"  "<left>"  #'my/resize-window-left)
#+end_src
** Maximize window toggle

#+BEGIN_SRC emacs-lisp
  (defvar toggle-one-window-window-configuration nil
    "The window configuration use for `toggle-one-window'.")
  (defun toggle-one-window ()
    "Toggle between window layout and one window."
    (interactive)
    (if (equal (length (cl-remove-if #'window-dedicated-p (window-list))) 1)
        (if toggle-one-window-window-configuration
            (progn
              (set-window-configuration toggle-one-window-window-configuration)
              (setq toggle-one-window-window-configuration nil))
          (message "No other windows exist."))
      (setq toggle-one-window-window-configuration (current-window-configuration))
      (delete-other-windows)))
  (general-define-key
   :prefix "C-c"
   "m" 'toggle-one-window)

#+END_SRC
rqjjj
** zoom
#+begin_src emacs-lisp :tangle yes
(use-package! zoom
  :init
  (setq zoom-size '(0.618 . 0.618)) ;; golden ratio
  (setq zoom-ignored-major-modes '(dired-mode vterm-mode))
  (setq zoom-ignore-predicates
        (list (lambda () (< (count-windows) 2))
              (lambda () (memq major-mode zoom-ignored-major-modes))))
  :config
  (zoom-mode 1))
#+end_src
* Workspace & Session
** minimum tab
#+begin_src emacs-lisp
;; (use-package! sort-tab
;;   :after doom-modeline
;;   :config
;;   (sort-tab-mode 1)
;;   (defun my/refresh-tab ()
;;     (interactive)
;;     (message "Refreshing tabs...")
;;     (sort-tab-turn-off)
;;     (sort-tab-turn-on))
;;   (defun my/sort-tab-hide-buffer (buffer)
;;     "Hide BUFFER if it's not in the current Doom workspace or is a Dired buffer."
;;     (or (not (member (buffer-name buffer)
;;                      (mapcar #'buffer-name (+workspace-buffer-list))))
;;         (eq (buffer-local-value 'major-mode buffer) 'dired-mode)))

;;   (setq sort-tab-hide-function #'my/sort-tab-hide-buffer)
;;   ;; Add advice to +workspace/switch-to
;;   (advice-add '+workspace/switch-to :after
;;     (lambda (index-or-name &rest _)
;;       (my/refresh-tab)))
;;   (map! :n "H" #'sort-tab-select-prev-tab
;;         :n "L" #'sort-tab-select-next-tab)
;; )
#+end_src

** session
#+begin_src emacs-lisp
;; save doom emacs session every 15 minute
(run-with-timer 900 900 #'doom/quicksave-session)
#+end_src

* UI
#+begin_src emacs-lisp
(setq doom-theme 'doom-gruvbox)
(setq display-line-numbers-type t)
(setq doom-font (font-spec :family "JetBrains Mono" :size 22)
      doom-variable-pitch-font (font-spec :family "Cantarell" :size 15)
      doom-big-font (font-spec :family "JetBrains Mono" :size 34))
(after! doom-themes
  (setq doom-themes-enable-bold t
        doom-themes-enable-italic t))
(custom-set-faces!
  '(font-lock-comment-face :slant italic)
  '(font-lock-keyword-face :slant italic))
(global-visual-line-mode)
#+end_src
** Doom Mode Line
#+begin_src emacs-lisp
(after! doom-modeline
  (setq doom-modeline-persp-name t))
#+end_src
* Org mode
#+begin_src emacs-lisp
(setq org-directory "~/Documents/org/")
(after! org
  (set-company-backend! 'org-mode
    '(:separate company-files company-capf company-dabbrev company-yasnippet)))
#+end_src
** org ui
#+begin_src emacs-lisp
;; Set bold text color after Org and theme load
(after! org
  (setq org-hide-emphasis-markers t)
  (custom-set-faces!
    '(org-bold :foreground "#FF5555" :weight bold :inherit nil)))
#+end_src
** Agenda
#+begin_src emacs-lisp
(after! org
  (setq org-agenda-dir "~/Documents/org/jira/")
  (setq org-agenda-files (directory-files-recursively org-agenda-dir "\\.org$"))
  ;; save all org files after change todo
  (defmacro η (fnc)
     "return function that ignores its arguments and invokes fnc."
     `(lambda (&rest _rest)
      (funcall ,fnc)))
  (advice-add 'org-deadline       :after (η #'org-save-all-org-buffers))
  (advice-add 'org-schedule       :after (η #'org-save-all-org-buffers))
  (advice-add 'org-store-log-note :after (η #'org-save-all-org-buffers))
  (advice-add 'org-todo           :after (η #'org-save-all-org-buffers))
  (advice-add 'org-priority       :after (η #'org-save-all-org-buffers)))
#+end_src
** Refile
#+begin_src emacs-lisp :tangle yes
(after! org
  (defun my/org-refile-update-targets ()
    "Update `org-refile-targets` to match `org-agenda-files`."
    (setq org-refile-targets
          (mapcar (lambda (file) (cons file '(:maxlevel . 3))) org-agenda-files)))

  ;; Run once on startup
  (my/org-refile-update-targets)

  ;; Update targets whenever `org-agenda-files` changes
  (add-hook! 'org-agenda-mode-hook #'my/org-refile-update-targets)
  (add-hook! 'org-mode-hook #'my/org-refile-update-targets))
#+end_src
** or pomodoro
#+begin_src emacs-lisp
(after! org-pomodoro
  (setq org-pomodoro-audio-player "mpv"
    org-pomodoro-ticking-sound-p t
    org-pomodoro-ticking-sound-states '(:pomodoro)
    org-pomodoro-finished-sound-p t
    org-pomodoro-short-break-length 5
    org-pomodoro-finished-sound-args "--volume=50"
    org-pomodoro-long-break-sound-args "--volume=50"
    org-pomodoro-short-break-sound-args "--volume=50"
    org-pomodoro-ticking-sound-args "--volume=60"))
#+end_src
** org-jira
#+BEGIN_SRC emacs-lisp
(after! org-jira
  (setq org-jira-working-dir "~/Documents/org/jira/")
  (setq jiralib-url "https://jira.vni.agileci.conti.de")
  (setq jiralib-token
    (cons "Authorization"
      (concat "Bearer " (auth-source-pick-first-password
			 :host "jira.vni.agileci.conti.de"))))
  (setq org-jira-use-status-as-todo nil)
  (setq org-jira-jira-status-to-org-keyword-alist
   '(("Working" . "STRT")
     ("New" . "TODO")
     ("Ready" . "TODO")
     ("Closed" . "DONE")
     ("Verifying" . "STRT"))))
#+END_SRC

#+RESULTS:
: ((Working . STRT) (New . TODO) (Ready . TODO) (Closed . DONE) (Verifying . STRT))

** org-anki
#+BEGIN_SRC emacs-lisp
(use-package! org-anki
  :config
  (setq org-anki-default-deck "Mega"))
(map! :leader
  (:prefix ("o" . "org")
   :prefix ("ok" . "org anki")
   :desc "anki sync entry" "s" 'org-media-note-show-interface))
#+END_SRC

** org-download
#+BEGIN_SRC emacs-lisp
(defun my/org-download-method (link)
    (let ((filename
           (file-name-nondirectory
            (car (url-path-and-query
                  (url-generic-parse-url link)))))
          (dirname (concat "~/Documents/org/notes/images/" (file-name-sans-extension (file-name-nondirectory (buffer-file-name))))))
      (setq org-download-image-dir dirname)
      (make-directory dirname t)
      (expand-file-name (funcall org-download-file-format-function filename) dirname)))

(defun my/org-download-clipboard-wsl ()
  (interactive)
  (let* ((image-name (read-string "enter image name (without extension): "))
         (filename (expand-file-name (concat image-name ".png") "/tmp/"))
         (powershell-path "/mnt/c/windows/system32/windowspowershell/v1.0/powershell.exe"))
    ;; use full path to powershell
    (shell-command-to-string
     (format "%s -command \"(get-clipboard -format image).save('$(wslpath -w %s)')\"" powershell-path filename))
    (when (file-exists-p filename)
      (org-download-image filename)
      (delete-file filename))))

(defun my/org-download-clipboard ()
  (interactive)
  (cond (my/is-windows (my/org-download-clipboard-windows))
        (my/is-WSL (my/org-download-clipboard-wsl))
        (t (org-download-clipboard)))) ; for linux and mac system

(setq org-image-actual-width nil)
(use-package! org-download
  :after org
  :config
    (setq org-download-method 'directory)
  :custom
    (org-download-heading-lvl 1)
    (org-download-method #'my/org-download-method)
  :bind (:map org-mode-map
              ("C-c i y" . org-download-yank)
              ("C-c i d" . org-download-delete)
              ("C-c i e" . org-download-edit)
              ("C-M-y" . my/org-download-clipboard)))
#+END_SRC

** org-roam
*** custom function and variables
#+begin_src emacs-lisp :tangle yes
(defvar my/org-roam-project-template
  '("p" "project" plain "** TODO %?"
    :if-new (file+head+olp "%<%Y%m%d%H>-${slug}.org"
                           "#+title: ${title}\n\n#+category: ${title}\n#+filetags: Project\n"
                           ("tasks"))))
(defun my/org-roam-filter-by-tag (tag-name)
  (lambda (node)
    (member tag-name (org-roam-node-tags node))))
(defun my/org-roam-list-notes-by-tag (tag-name)
  (mapcar #'org-roam-node-file
    (seq-filter
      (my/org-roam-filter-by-tag tag-name)
      (org-roam-node-list))))
(defun my/org-roam-filter-by-tags (wanted unwanted)
  (lambda (node)
  (let ((node-tags (org-roam-node-tags node)))
    (and (cl-some (lambda (tag) (member tag node-tags)) wanted)
         (not (cl-some (lambda (tag) (member tag node-tags)) unwanted))))))
(defun my/org-roam-refresh-agenda-list ()
  (interactive)
  (setq org-agenda-files
        (delete-dups (append org-agenda-files
                             (my/org-roam-list-notes-by-tag "Project")))))
;; for projects
(defun my/org-roam-project-finalize-hook ()
  "adds the captured project file to `org-agenda-files' if the
  capture was not aborted."
  ;; remove the hook since it was addd temporarily
  (remove-hook 'org-capture-after-finalize-hook #'my/org-roam-project-finalize-hook)
  ;; add project file to the agenda list if the capture was confirmed
  (unless org-note-abort
    (with-current-buffer (org-capture-get :buffer)
      (add-to-list 'org-agenda-files (buffer-file-name)))))

(defun my/org-roam-insert-new-project ()
  (interactive)
  ;; add the project file to the agenda after capture is finished
  (add-hook 'org-capture-after-finalize-hook #'my/org-roam-project-finalize-hook)
  ;; select a project file to open, creating it if necessary
  (org-roam-capture- :node (org-roam-node-read
                            nil
                            (my/org-roam-filter-by-tag "Project"))
                     :templates (list my/org-roam-project-template)))

(defun my/org-roam-find-project ()
  (interactive)
  ;; add the project file to the agenda after capture is finished
  (add-hook 'org-capture-after-finalize-hook #'my/org-roam-project-finalize-hook)
  ;; select a project file to open, creating it if necessary
  (org-roam-node-find
   nil
   nil
   (my/org-roam-filter-by-tags '("Project") '("Archived"))))
;; new todo in project
(defun my/org-roam-capture-task ()
(interactive)
;; update org-agenda list after adding projects
(add-hook 'org-capture-after-finalize-hook #'my/org-roam-project-finalize-hook)
;; new todo
(org-roam-capture- :node (org-roam-node-read
                          nil
                          (my/org-roam-filter-by-tag "Project"))
                   :templates (list my/org-roam-project-template)))

(defun my/org-roam-copy-todo-to-today ()
 (interactive)
 (unless (or (string= (buffer-name) "*habit*") ; do nothing in habit buffer
         (string= (org-entry-get nil "STYLE") "habit")) ; skip if the task is a habit
   (let ((org-refile-keep t) ; set this to nil to delete the original!
         (org-roam-dailies-capture-templates
          '(("t" "tasks" entry "%?"
             :if-new (file+head+olp "%<%Y-%m-%d>.org" "#+title: %<%Y-%d-%d>\n" ("Done")))))
         (org-after-refile-insert-hook #'save-buffer)
         today-file
         pos)
     (save-window-excursion
       (org-roam-dailies--capture (current-time) t)
       (setq today-file (buffer-file-name))
       (setq pos (point)))
     ;; only refile if the target file is different than the current file
     (unless (equal (file-truename today-file)
                    (file-truename (buffer-file-name)))
       (org-refile nil nil (list "Done" today-file nil pos))))))

(defun org-roam-node-insert-immediate (arg &rest args)
  (interactive "P")
  (let ((args (push arg args))
        (org-roam-capture-templates (list (append (car org-roam-capture-templates)
                                                  '(:immediate-finish t)))))
    (apply #'org-roam-node-insert args)))
#+end_src

*** core
#+begin_src emacs-lisp
;; Org-roam configuration for Doom Emacs
(after! org-roam
  (setq my/daily-note-filename "%<%Y-%m-%d>.org"
      my/daily-note-header "#+title: %<%Y-%m-%d %a>\n\n[[roam:%<%Y-w%W>]]\n\n[[roam:%<%Y-%B>]]\n\n* Tasks\n\n* Captures\n** Information\n** Opinions\n** Efficiency\n** Feelings\n\n* Reflection\n** One thing Good\n** One thing bad\n\n* AI summary\n\n")
  (setq org-roam-directory "~/Documents/org/notes/"
        org-roam-completion-everywhere t
        org-roam-node-display-template
        (concat "${title:*} " (propertize "${tags:10}" 'face 'org-tag))
        org-roam-db-gc-threshold most-positive-fixnum
        org-roam-dailies-directory "daily/"
        org-roam-dailies-capture-templates
        `(
          ("d" "default" entry "* %?"
            :if-new (file+head ,my/daily-note-filename
                               ,my/daily-note-header))
          ("f" "Feelings entry" entry "* %?"
            :if-new (file+head+olp ,my/daily-note-filename
                                  ,my/daily-note-header
                                  ("Captures" "Feelings")))
        )
        org-roam-capture-templates
        '(
          ("d" "default" plain "%?"
            :target (file+head "%<%y%m%d%h%m%s>-${slug}.org" "#+title: ${title} \n")
            :unnarrowed t)
          ("h" "Hugo Blog Post" plain (file "~/Documents/org/templates/hugo-post.org")
            :target (file+head "%<%y%m%d%h%m%s>-${slug}.org" "")
            :unnarrowed t)
        )
  )
  ;; Keybindings
  (map! :leader
        :desc "Toggle org-roam buffer" "n r l" #'org-roam-buffer-toggle
        :desc "Capture org-roam note" "n r c" #'org-roam-capture
        :desc "Insert org-roam node" "n r i" #'org-roam-node-insert
        :desc "Insert immediate org-roam node" "n r I" #'org-roam-node-insert-immediate
        :desc "Capture org-roam task" "n r t" #'my/org-roam-capture-task
        :desc "Insert new project" "n r P" #'my/org-roam-insert-new-project
        :desc "Find project" "n r p" #'my/org-roam-find-project
        :desc "Toggle org-roam UI" "n r u" #'org-roam-ui-mode)

  ;; Additional keybindings for Org mode
  (map! :map org-mode-map
        "C-M-i" #'completion-at-point)
  (advice-add 'org-agenda :before #'my/org-roam-refresh-agenda-list)
 )
#+end_src
*** org-roam-ui
#+begin_src emacs-lisp
(use-package! org-roam-ui
  :config
    (setq org-roam-ui-sync-theme t)
    (setq org-roam-ui-follow t)
    (setq org-roam-ui-update-on-save t)
    (setq org-roam-ui-open-on-start t))

#+end_src
** org-noter
#+begin_src emacs-lisp :tangle yes
(use-package! org-noter
    :custom
    (org-noter-highlight-selected-text t)
    (org-noter-notes-search-path (list org_notes))
    :config
    (setq org-noter-auto-save-last-location nil)
    (setq org-noter-always-create-frame nil))
#+end_src
** org-media-note
#+begin_src emacs-lisp
(use-package! org-media-note
  :init (setq org-media-note-use-org-ref t)
  :hook (org-mode .  org-media-note-mode)
  :config
  (setq org-media-note-screenshot-image-dir "~/Documents/org/notes/images/")  ;; Folder to save screenshot
  (setq org-media-note-use-refcite-first t)  ;; use videocite link instead of video link if possible
  (map! :leader
        (:prefix ("n" . "notes")
         :desc "media note" "m" 'org-media-note-show-interface)))
#+end_src

** org-babel
#+begin_src emacs-lisp
(org-babel-do-load-languages
  'org-babel-load-languages
  '((emacs-lisp . t)
    (plantuml . t)
    (python . t)))
(setq org-confirm-babel-evaluate nil)
(add-hook 'org-babel-after-execute-hook 'org-redisplay-inline-images)
#+end_src

* Coding
** treesitter
#+begin_src emacs-lisp :tangle yes
(after! treesit
  (setq treesit-font-lock-level 4) ;; Enables all possible highlighting
  (add-to-list 'treesit-extra-load-path "~/.config/doomemacs/.local/straight/build-30.1/tree-sitter-langs/bin/"))

#+end_src
** lsp
#+begin_src emacs-lisp
(use-package! eglot-booster
	:after eglot
	:config	(eglot-booster-mode))
#+end_src
** tag
#+begin_src emacs-lisp :tangle yes
(use-package! citre
  :init
  ;; Optional: Enable Citre globally or in specific modes
  (add-hook 'prog-mode-hook #'citre-mode)
  ;; Bind Citre commands to Doom’s leader key
  (map! :leader
        (:prefix "c"  ; SPC c for code commands
         :desc "Jump to definition" "d" #'citre-jump
         :desc "Jump back" "b" #'citre-jump-back
         :desc "Jump back" "u" #'citre-update-this-tags-file
         :desc "Peek definition" "p" #'citre-peek))
  :config
  ;; Enable Citre in supported buffers automatically
  (citre-auto-enable-citre-mode)
  ;; Define tags file names Citre should look for
  (setq citre-default-tags-files '(".tags" "tags" "TAGS"))
  ;; Optional: Integrate with LSP if you use it
  (when (and (modulep! :tools lsp) (featurep 'lsp))
    (citre-lsp-integration)))
#+end_src
** algo
#+begin_src emacs-lisp
(use-package! leetcode
  :config
  (setq leetcode-prefer-language "python3"
        leetcode-prefer-sql "mysql"
        leetcode-directory "~/Documents/org/leetcode"
        leetcode-save-solutions t))
#+end_src
* External tools
** eee
external TUI tools
#+begin_src emacs-lisp
(after! eee
  (when my/is-WSL
    (setq ee-terminal-command "st"))
  (when my/is-mac
    (setq ee-terminal-command "wezterm"))
  (map! :leader
        (:prefix ("t" . "toggle")
         :desc "Lazygit" "g" #'ee-lazygit
         :desc "Yazi" "y" #'ee-yazi)))
#+END_SRC

** AI
*** AIDER
#+begin_src emacs-lisp
(use-package! aidermacs
  :bind (("C-c a" . aidermacs-transient-menu))
  :custom
  ; See the Configuration section below
  (aidermacs-use-architect-mode t)
  (setq aidermacs-backend 'vterm)
  (setq aidermacs-vterm-multiline-newline-key "S-<return>")
  (setq aidermacs-config-file "~/.aider.conf.yml"))
#+end_src


*** GPTEL
#+BEGIN_SRC emacs-lisp
(use-package! gptel
  :config
  ;; Retrieve API key securely
  ;; (setq gptel-api-key (auth-source-pick-first-password :host "api.openai.com" :user "apikey"))
  (setq gptel-api-key
        (auth-source-pick-first-password :host "openrouter.ai" :user "openrouter-apikey"))

  ;; Use OpenRouter's API endpoint
  (setq gptel-backend (gptel-make-openai "OpenRouter"
                      :host "openrouter.ai"
                      :endpoint "/api/v1/chat/completions"
                      :key gptel-api-key
                      :models '(deepseek/deepseek-r1:free
                                openai/gpt-4o-2024-11-20
                                anthropic/claude-3.7-sonnet)))
  ;; Keybinding to quickly open `gptel`
  (map! :leader
     :desc "Chat with GPT via OpenRouter"
     "o p" #'gptel))

#+END_SRC

* Snippet
#+begin_src emacs-lisp :tangle yes
(use-package! yasnippet
  :init
  (add-hook 'yas-minor-mode-hook (lambda()
				       (yas-activate-extra-mode 'fundamental-mode)))
  :config
  (setq yas-snippet-dirs '("~/dotconfig/emacs/doom/snippets")))
#+end_src
* Chinese
** Rime
#+begin_src emacs-lisp
(use-package! rime
  :config
  (setq rime-user-data-dir "~/dotconfig/rime")
  ;; mac needs to manually download librime and set these path for compilation
  (when my/is-mac
    (setq rime-librime-root "~/.emacs.d/librime/dist")
    (setq rime-emacs-module-header-root "/opt/homebrew/Cellar/emacs-plus@30/30.1/include"))
  (setq default-input-method "rime"
        rime-show-candidate 'posframe
        rime-disable-predicates
        '(rime-predicate-evil-mode-p
          rime-predicate-after-ascii-char-p
          rime-predicate-hydra-p
          rime-predicate-tex-math-or-command-p
          rime-predicate-prog-in-code-p))
  ;; Prevent rime crash on exit
  (defun rime-lib-finalize () nil)
  (add-hook 'kill-emacs-hook #'rime-lib-finalize))
#+end_src
** spacing
#+begin_src emacs-lisp
(after! pangu-spacing
  (setq pangu-spacing-real-insert-separator t) ;; Enable real spacing
  (global-pangu-spacing-mode 1)) ;; Enable globally
#+end_src
